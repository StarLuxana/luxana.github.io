[{"id":"4b14249281608a1ca0cb2d884dbaa0d8","title":"正则表达式必知必会","content":"正则表达式入门什么是正则表达式\n正则表达式是一些用来匹配和处理文字的字符串。\n正则表达式是用正则表达式语言创建的。\n正则表达式语言并不是一种完备的程序设计语言，而是内置于其他语言或软件产品里的“迷你”语言。\n\n使用正则表达式\n并非所有的正则表达式实现都是一样的。在不同的应用程序/语言里，正则表达式的语法和功能往往会有明显的差异\n\n匹配单个字符匹配普通文本正则表达式可以包含普通文本，以普通文本为正则表达式可以搜索到文本中所有包含普通文本的部分。\n绝大多数正则表达式引擎的默认行为是只返回第一个匹配结果，而非返回全部匹配结果。\n如果要找出所有匹配结果，则应选择全局搜索。\n正则表达式是区分字母大小写的。\n如果要找出不区分大小写的匹配普通文本，可以选择强制执行不区分大小写的搜索。\n匹配任意字符在正则表达式里，特殊字符（或字符集合）用来标识要搜索的东西。\n.字符（英文句号）可以匹配任意单个字符\n在同一个正则表达式里允许使用多个.字符，它们既可以共同出现，也可以出现在模式的不同位置\n模式：实际的正则表达式\n匹配特殊字符.字符在正则表达式里有着特殊的意义。如果模式里需要一个.字符本身而不是它在正则表达式里的特殊含义，必须在.的前面加上一个\\（反斜杠）字符来对它进行转义。\n\\是一个元字符。\n元字符：字符有特殊含义，代表的不是字符本身。\n如果需要搜索\\本身，就必须对\\字符进行转义。相应的转义序列是两个连续的反斜杠\\。\n匹配一组字符匹配多个字符中的某一个在正则表达式里，我们可以使用元字符[]来定义一个字符集合。在使用[]定义的字符集合里，出现在[]之间的所有字符都是该集合的组成部分，必须匹配其中某个成员（但并非全部）。\n利用字符集合区间正则表达式提供了一个特殊的元字符：可以用-（连字符·）来定义字符区间(09、AZ等)。\n\nA-Z：所有大写字母\na-z：所有小写字母\nA-F：从A到F的所有大写字母\nA-z：ASCII字符A到ASCII字符z的所有字母，除了大小写字母外还包括^和[]等字符\n\n-（连字符）是一个特殊的连字符，它只有出现在[]之间的时候才是元字符。字符集合以外的地方，-只是一个普通字符，不需要被转义。\n排除可以使用元字符^来排除某个字符集合。\n使用元字符再谈转义因为元字符在正则表达式里有着特殊的含义，所以这些字符就无法用来代表它们本身。\n配对的元字符不用作元字符时必须被转义，否则正则表达式解析器可能会抛出一个错误。\n匹配空白字符在进行正则表达式搜索的时候，我们经常会需要匹配文本中的非打印空白字符。\n\n\n\n元字符\n说明\n\n\n\n[\\b]\n回退（并删除）一个字符（Backspace）\n\n\n\\f\n换页符\n\n\n\\n\n换行符\n\n\n\\r\n回车符\n\n\n\\t\n制表符（Tab）\n\n\n\\v\n垂直制表符\n\n\n\\n\\r是Windows系统所使用的文本行结束标记。而Unix/Linux系统以及Mac OS只使用了一个换行符。换句话说，在这些系统上匹配空白行只使用\\n即可，不需要加上\\r。\n匹配特定的字符类型\n\n\n元字符\n说明\n\n\n\n\\d\n任何一个数字字符\n\n\n\\D\n任何一个非数字字符\n\n\n\\w\n任何一个字母数字字符或下划线字符\n\n\n\\W\n任何一个非字母数字字符或非下划线字符\n\n\n\\s\n任何一个空白字符\n\n\n\\S\n任何一个非空白字符\n\n\n\\x\n十六进制值\n\n\n\\0\n八进制值\n\n\n使用POSIX字符类\n\n\n字符类\n说明\n\n\n\n[:alnum:]\n任何一个数字或字母\n\n\n[:alpha:]\n任何一个字母\n\n\n[:blank:]\n空格或制表符\n\n\n[:cntrl:]\nASCII控制字符\n\n\n[:digit:]\n任何一个数字\n\n\n[:graph:]\n任何一个可打印字符，但不包括空格\n\n\n[:lower:]\n任何一个小写字母\n\n\n[:print:]\n任何一个可打印字符\n\n\n[:punct:]\n既不属于[:alnum:]也不属于[:cntrl:]的任何一个字符\n\n\n[:space:]\n任何一个空白字符，包括空格\n\n\n[:upper:]\n任何一个大写字母\n\n\n[:xdigit:]\n任何一个十六进制数字\n\n\nJavaScript不支持在正则表达式里使用POSIX字符类\n重复匹配有多少个匹配要想匹配某个字符（或字符集合）的一次或多次重复，只要简单地在其后面加上一个+字符就行了。\n给一个字符集合加上+后缀的时候，必须把+放在这个字符集合的外面。\n当在字符集合里使用的时候，元字符将被解释为普通字符，不需要转义，但转义了也没有坏处。\n只要把*字符放在某个字符（或字符集合）的后面，就可以匹配该字符（或字符集合）出现零次或多次的情况。\n?字符能够匹配某个字符（或字符集合）的零次或一次出现，最多不超过一次。\n把一个字符也定义成一个集合可以增加可读性和避免·产生误解。\n匹配的重复次数要想设置具体的匹配次数，把数字写在{}之间即可。\n{}语法还可以用来为重复匹配次数设定一个区间范围，也就是匹配的最小次数和最大次数，中间用,间隔，即{最小次数,最大次数}。\n为避免不必要的麻烦，在需要匹配/字符本身的时候，最好总是使用它的转义序列。\n区间范围语法可以省略最大值部分，指定至少要匹配多少次，即{最小次数,}。\n防止过度匹配*和+都是所谓的”贪婪型”元字符，其匹配行为是多多益善而不是适可而止。它们会尽可能地从一段文本地开头一直匹配到末尾，而不是碰到第一个匹配时就停止。这是有意设计的，量词就是贪婪的。\n量词：+、*和？\n在不需要这种”贪婪行为”的时候应该使用这些量词的”懒惰型”版本。懒惰型量词的写法是在贪婪型量词后面加上一个?。\n\n\n\n贪婪型量词\n懒惰型量词\n\n\n\n*\n*？\n\n\n+\n+？\n\n\n{n,}\n{n,}?\n\n\n位置匹配边界一些用于指定模式前后位置（或边界）的特殊元字符\n单词边界\\b用来匹配一个单词的开头或结尾。\n\\b匹配的是字符之间的一个位置：一边是单词（\\w），另一边是其他内容（\\W）。\n\\B匹配的是字符之间的一个位置：两边都是单词（\\w），或两边都是其他内容（\\W）\n字符串边界字符串边界可以用来对字符串位置进行匹配，只不过用在字符串首尾进行模式匹配。字符串边界元字符有两个：^代表字符串开头，$代表字符串结尾。\n有些元字符拥有多种用途，^就是其中之一。只有当它出现在字符集合里且紧跟在左方括号的后面时，它才表示排除该字符集合。如果出现在字符集合之外并位于模式的开头，^将匹配字符串的起始位置。\n许多正则表达式都支持使用一些特殊的元字符去改变另外一些元字符的行为，(？m)就是其中之一，它可用于启动多行模式。多行模式迫使正则表达式引擎将换行符视为字符串分隔符，这样一来^既可以匹配字符串开头，也可以匹配换行符之后的起始位置；$不仅能匹配字符串结尾，还能匹配换行符之后的结束位置。\n在使用时，(？m)必须出现在整个模式的最前面。\n包括JavaScript在内的许多正则表达式实现都不支持(？m)。\n使用子表达式理解子表达式用来表明重复次数的元字符只作用于紧挨着它的前一个字符或元字符。\n使用子表达式进行分组子表达式是更长的表达式的一部分。划分子表达式的目的是为了将其视为单一的实体来使用。子表达式必须出现在()之间。\n把表达式的某些部分加上括号，形成子表达式，以此提高可读性。\n|是OR（或）操作符，它可以匹配前一个字符串或后一个字符串。\n子表达式的嵌套子表达式可以多重嵌套。\n模式是从左到右进行评估的，所以当有多个表达式都可以匹配时，首先测试第一个，然后测试第二个，以此类推。只要有任何模式匹配，就不再测试选择结构中的其他模式。\n反向引用反向引用匹配反向引用：这些实体引用的是先前的表达式。\n\\1匹配模式中所使用的第一个子表达式，\\2匹配模式中所使用的第二个子表达式，以此类推。\n在不同的正则表达式实现中，反向引用的语法差异不小。\n反向引用只能用来引用括号里的子表达式。\n\\0可以用来代表整个正则表达式。\n移动或编辑子表达式可能会使模式失效，删除或添加子表达式的后果甚至会更严重。\n替换操作替换操作需要用到两个正则表达式：一个用来指定搜索模式，另一个用来指定替换模式。反向引用可以跨模式使用，在第一个模式里匹配的子表达式可以用在第二个模式里。\n有些正则表达式实现允许我们使用元字符对字母进行大小写转换。\n\n\n\n元字符\n说明\n\n\n\n\\E\n结束\\L或\\U转换\n\n\n\\l\n把下一个字符转换成小写\n\n\n\\L\n把\\L到\\E之间的全部字符转换成小写\n\n\n\\u\n把下一个字符转换成大写\n\n\n\\U\n把\\U到\\E之间的全部字符转换成大写\n\n\n环视环视简介环视：一些不用被返回的匹配——这些匹配是为了找出正确的匹配位置，其本身不属于最终的匹配结果。\n向前查看向前查看指定了一个必须匹配但不用在结果中返回的模式。\n向前查看模式的语法是一个以?=开头的子表达式，需要匹配的文本跟在=后面.\n向后查看除了向前查看，许多正则表达式实现还支持向后查看，也就是查看出现在以匹配的文本之前的内容，向后查看操作符是?&lt;=。\n?&lt;=的用法与?=一样。它必须出现在一个子表达式里，后面跟随要匹配的文本。\n向前查看模式的长度是可变的，其中可以包含量词，所以非常灵活\n向后查看模式则只能是固定长度。几乎所有的正则表达式实现都有此限制\n否定式环视向前查看和向后查看通常都是用来匹配文本，主要用于指定作为匹配结果返回的文本位置。这种用法被称作肯定式向前查看和肯定式向后查看。\n环视还有一种不太常见的形式叫作否定式环视。否定式环视向前查看会向前查看不匹配指定模式的文本，否定式向后查看则向后查看不匹配指定模式的文本。\n\n\n\n种类\n说明\n\n\n\n(?=)\n肯定式向前查看\n\n\n(?!)\n否定式向前查看\n\n\n(?&lt;=)\n肯定式向后查看\n\n\n(?&lt;!)\n否定式向后查看\n\n\n嵌入式条件正则表达式里的条件反向引用条件仅在一个前面的子表达式得以匹配的情况下才允许使用另一个表达式。\n用来定义这种条件的语法是(?(反向引用)表达式)，其中?表明这是一个条件，括号里是一个反向引用，仅当反向引用立即出现时，才对表达式求值。\n条件还可以有else表达式，仅当给定的反向引用不存在时才执行该表达式，用来定义这种条件的语法是(?(反向引用)表达式|表达式)。此语法接受一个条件和两个分别在符合/不符合该条件时执行的表达式。\n","slug":"book_note_1","date":"2023-01-01T06:22:00.000Z","categories_index":"","tags_index":"读书笔记","author_index":"Luxana"}]